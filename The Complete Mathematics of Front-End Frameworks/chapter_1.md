# 第 1 章 --- UI = 映射：集合论与投影（完整版）

## 核心观点

UI 是一个从状态空间到 UI 树的数学映射。

**UI = f(state)**

所有前端框架本质上都在努力让这个映射保持：**纯净、可控、可推理**。

------------------------------------------------------------------------

## 1.1 UI 不是过程（命令）------它是一个函数（映射）

普通工程师会这样理解 UI： - 改一个 state → 操作 DOM → 更新 UI

数学化的工程师会这样理解 UI：

**UI = f(State)**\
UI 是对状态空间的投影结果。

React 带给开发者最大的观念改变是：

> "你不是命令 DOM，你是在描述 DOM。"

这是一种从： - **命令式（imperative）** → **声明式（declarative）**
的转换

你不再告诉系统 *如何* 更新 UI，而是在声明：UI
*应该是什么样子*（由状态决定）。

### 数学语言补充：

**render : State → VNodeTree**

------------------------------------------------------------------------

## 1.2 State 是啥？------一个集合中的"点"

假设 State 是一个笛卡尔积结构：

``` code
State = User × Theme × List(Item) × Bool
```

那么某一刻的 state 是这个空间中的一个"点"：

``` code
s ∈ State
```

而 UI 就是该点的投影结果：

``` code
UI = render(s)
```

这种映射具有数学上的三个性质：

-   **确定性（Determinism）**：同一状态 → 同一 UI
-   **不可逆（Not Injectable）**：UI 看不回 state
-   **可组合（Composable）**：多组件就是多投影函数的组合

------------------------------------------------------------------------

## 1.3 Virtual DOM 是一个代数数据类型（ADT）

数学上，VNode 的结构如下：

``` code
VNode = Element(Type, Props, [VNode...])
      + Text(String)
```

这是典型的 ADT 定义：

-   **Sum**：元素或文本
-   **Product**：元素 = 类型 × 属性 × 子节点列表
-   **递归**：children = VNode 列表

UI 树定义：

``` code
VNodeTree = VNode*
```

这是一个**递归代数数据类型（Recursive ADT）**。

React 能做 diff，就是因为 ADT 严格定义了： - 结构\
- 可能性\
- 不变量（invariants）

换句话说：

> **React "可优化"，是因为 UI 有数学结构，而不是 DOM 有数学结构。**

------------------------------------------------------------------------

## 1.4 组件（Component）是某个状态空间的投影算子

组件函数：

``` code
Component : State → VNodeTree
```

如果一个组件只关心局部状态 S₁：

``` code
Component = f ∘ π₁
```

其中： - **π₁ 是笛卡尔积上的投影（projection）** - **f 是局部渲染函数**

这就是：

### **组件拆分 = 拆分状态空间的投影算子**

所以你总觉得 React "特别数学"， 因为组件化不是 UI 拆块， 而是
**状态空间分解**。

------------------------------------------------------------------------

## 1.5 为什么 UI 必须是"纯函数"？

一个核心理由：

> **只有纯映射才能被证明、组合、缓存、优化。**

如果 render 有副作用： - 调用一次产生 A - 再调一次产生 B -
状态回放会失败 - React 无法在 Fiber 中随意重放 - 调度系统会崩溃

纯函数的数学性质提供： - **可重放（replay）** - **可裁剪（slice）** -
**可中断（interruptible）** - **可并行（independent）** -
**可推理（provable）**

这些都是 Fiber 能存在的基础。

------------------------------------------------------------------------

## 1.6 为什么"投影"（Projection）非常适合 UI？

让我们从数学上解释 React 的设计哲学：

-   **状态空间是高维**
-   **UI 是低维**
-   **映射是降维**
-   **降维必然丢失信息 → UI 不可逆**
-   **丢失信息代表 UI 永远不能决定业务**
-   **UI 只是投影，不是逻辑中心**

所以 React 做的事不是 DOM 操作，而是：

### **把状态空间"投影"成 UI 样子**

就像线性代数里把向量投影到某个平面上一样。

你一直觉得 "React 的架构很干净"， 是因为它就是数学上的 **投影算子**。

# 第 2 章：状态空间（State）的数学结构：笛卡尔积、不变量与拓扑

## 核心命题

你看到的所有前端“状态管理”，其实是对 **笛卡尔积空间** 做整理。
不变量是几何结构，组件是投影算子。

---

## 2.1 状态 = 一个多维笛卡尔积（Product Type）

在工程中你看到：

```ts
const state = {
  user,
  theme,
  items,
  filters,
  loading,
}
```

数学上对应：

```code
State = U × T × List(Item) × F × Bool
```

其中每个字段都是一个维度（dimension）。

更多内容将在后续小节继续展开。

这说明：

* **管理状态 = 管理一个多维坐标空间**
* **UI 渲染 = 把一个高维点投影到 UI 上**

你为什么直觉上“很会 React 和 Redux”？

因为你擅长处理 **「空间 → 结构 → 投影」** 这一类数学问题。

---

## 2.2 不变量（Invariant）是前端真正的“规则”

例如：

* **loading = true → items 必须为空**
* **theme = dark → 背景必须是黑色**
* **user = null → 不能显示 Profile**

这些都是数学上的 **不变量约束（Constraints）**。

不变量定义了 State 空间中的合法区域（Valid Region）：

```code
Valid ⊂ State
```

所有前端框架的“规则”，本质上都是在保证：

```code
s ∈ Valid
```

Redux 的一个核心好处是：

> **reducer 不会让你跑到非法区域。**

它通过集中式、可推理的状态变换，
确保系统始终停留在状态空间的“可行子空间”内。

---

## 2.3 状态分片（Component‑level State）= 子空间投影

组件只关心局部状态：

```code
S_local ⊂ State
```

相当于：

```code
Component = f ∘ π_local
```

其中 **π_local** 是投影到子空间的算子。

这解释了：

* 为什么 **props 是只读的**（它是投影结果，不是原空间）
* 为什么 **state 应该拆分得清晰**（清晰的子空间更容易投影）
* 为什么 **hooks 是函数式的**（返回值本身就是一个局部状态空间）

---

## 2.4 状态拓扑（Topology）：状态是否“相邻”？

你可能曾经问过：

> “为什么某些 UI 状态之间自然过渡，另一些感觉生硬？”

因为在**状态空间**中：

* 有些点之间的“距离”很近（**拓扑相邻**）
* 有些点之间的“距离”很远（**非相邻跳跃**）

例如：

```code
"loading" → "empty" → "success"
```

这是**拓扑上相邻**的状态路径，
UI 过渡通常显得自然。

而：

```code
"loading" → "error"
```

属于**非相邻跳跃**，
UI 上会明显感觉“断裂”。

**优秀的 UI / UX，本质上是对状态拓扑的优化。**

也就是说：

* 减少远距离跳跃
* 增加中间态
* 让状态路径在拓扑上连续

---

## ⭐ 第 2 卷总结

> **React 不是在管理变量，它在管理一个“状态空间”的几何结构。**
> **Hook 是空间算子，reducer 是状态空间的演化定律。**

换句话说：

* 状态不是零散的数据，而是一个有结构的空间
* 规则不是 if/else，而是不变量约束
* 组件不是拼 UI，而是在做子空间投影
* 动画与体验，本质上是拓扑路径设计

当你用这种视角看前端，
React、Redux、Hooks、甚至 UI/UX，
都会变成同一套数学语言下的不同表现形式。

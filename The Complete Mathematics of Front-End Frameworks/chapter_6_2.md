# Fiber 遍历 vs 普通的树遍历

## Fiber 遍历和普通的树遍历的不同

Fiber 遍历和普通的树遍历的不同就是：

1. **可以在任意节点暂停**
2. **可以从任意一个父节点开始**

---

## ✅ 树本身就是拓扑结构（Topologically Ordered DAG）

这是完全正确的：

* 树 = 有向无环图（DAG）
* 父节点一定拓扑上排在子节点之前
* DFS / BFS 都是一种合法的拓扑排序

所以：

> 「树遍历 = 拓扑排序」
>
> 「遍历顺序 = UI 渲染顺序」

---

## ⭐ Fiber 与普通树遍历的真正区别（精确数学版本）

### 普通 DFS 遍历的性质

| 性质          | 普通 DFS           |
| ----------- | ---------------- |
| 是否能暂停       | ❌ 不能（递归栈连着）      |
| 是否能恢复       | ❌ 不能（栈 frame 消失） |
| 是否能从父节点重新开始 | ❌ 不能（路径丢失）       |
| 遍历顺序是否固定    | ✅ 是              |
| 是否支持调度      | ❌ 完全不支持          |

---

### ⭐ Fiber 的性质（这是最大差异）

| 性质         | Fiber DFS                  |
| ---------- | -------------------------- |
| 可以在任意节点暂停  | ✅ 随时可以停                    |
| 随时恢复       | ✅ 记录了 nextUnitOfWork       |
| 可以从任意父节点继续 | ✅ child / sibling / return |
| 遍历顺序       | ✅ 隐式拓扑序                    |
| 可被调度器打断和重排 | ✅ 时间切片 / 并发模式              |

---

## ①「可以在任意节点暂停」

是的，Fiber 最大的设计就是：

> 把递归 DFS 压平成迭代结构，
> 每一个 Fiber 都是一个可独立执行的 WorkUnit。

也就是说：

```js
performUnitOfWork(fiber)
```

* 只处理一个节点（或其一部分）
* 然后返回“下一个要处理的 Fiber”

React 可以：

* 做一半停下来
* 等浏览器空闲再继续
* 或被更高优先级任务（如输入）打断

这叫 **cooperative scheduling（协作式调度）**。

---

## ②「可以从任意一个父节点继续」

完全正确，因为 Fiber 明确保存了三类指针：

```ts
child   // 第一个子节点
sibling // 兄弟节点
return  // 父节点
```

这 3 个指针取代了递归栈，所以 React 能做到：

* 暂停后，下次从 nextUnitOfWork 接着执行
* 父节点可以被重新访问
* 兄弟节点可以被跳转执行
* 整棵树像链表一样被断点恢复

这是普通 DFS 做不到的。

---

## 🎯 真正的第 3 个区别：Fiber 允许「动态改变拓扑顺序」

这一点你已经**隐约触及**了。

普通 DFS 的遍历顺序是固定的：

* 子节点顺序固定
* 兄弟顺序固定
* 遍历过程中不能改变

而 Fiber 在遍历过程中可以：

* 根据 Priority Lane 跳过子树
* 直接 bail out 某些分支
* 插入更高优先级任务
* 在 Reconciliation 中替换子树

也就是说：

> Fiber 不只是“可暂停”，
> 而是 **遍历顺序本身可以在执行中被调度器动态调整**。

---

## 🔥 最终对比总结（黄金版本）

**普通树遍历（递归 DFS）**：

* 固定拓扑顺序
* 不能暂停
* 不能恢复
* 不能改变遍历方向
* 不能重排兄弟
* 不能插入更高优先级任务

**Fiber 遍历**：

> 本质：把树的拓扑序列
> 压平成一个 **可暂停 / 可恢复 / 可重排的线性任务流**。

具备能力：

1. ✅ 可以在任意节点暂停
2. ✅ 可以从任意父节点继续（包括父节点）
3. ⭐ 可以动态改变遍历顺序（调度）
4. ✅ 可以跳过低优先级子树
5. ✅ 可以让高优先级节点插队
6. ⭐ 允许中断式拓扑遍历（interruptible topological traversal）

---

## 一句话收束

> **Fiber = 允许中断、恢复、并动态调整顺序的拓扑遍历。**

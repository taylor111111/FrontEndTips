

# HTTP 并发管理问题（Promise 的工程本体）

> 这不是一篇 Promise 语法文章。
> 这是一篇 **HTTP 并发在前端工程中的问题定义与治理说明**。
>
> 核心结论只有一句话：
> **HTTP 并发管理是工程问题，而不是 Promise 链问题。**

---

## 一、为什么这是一个“工程本体”问题

在真实业务中，Promise 只是一个执行载体。
真正复杂的是：**当多个 HTTP 请求同时存在、多次触发、跨组件共享时，如何保证系统行为可预测、可维护、可回收。**

一旦进入以下任一场景，问题就已经升级为工程问题：
- 同一时间存在多条请求时间线
- 请求结果需要进入 UI 状态系统
- 请求需要被取消、去重、缓存、共享
- 请求生命周期与组件生命周期存在错位

---

## 二、最常见的 HTTP 并发业务场景

### 1. 多个不同请求并发（页面初始化）

**典型例子**
- 页面初始化：user / permission / config / list 并发加载
- 一个页面多个模块各自发起请求

**隐含工程问题**
- 是否并行？是否存在依赖顺序？
- 部分成功如何渲染 UI？
- 多个组件是否重复请求同一资源？
- 错误是否统一处理？是否需要重试？

---

### 2. 同一个请求被短时间多次触发（高频场景）

**典型例子**
- 搜索联想
- 过滤条件频繁变更
- 滚动加载 / 无限列表

**隐含工程问题**
- 是否需要取消旧请求？
- 是否需要去重？
- 如何避免旧请求晚返回覆盖新结果？
- 是否复用历史结果（缓存）？

---

### 3. 多组件 / 多页面共享同一服务端状态

**典型例子**
- 顶部用户信息 + 设置页 + 个人中心
- 列表页和详情页使用同一资源

**隐含工程问题**
- 是否共享缓存？
- 更新后如何同步？
- 什么时候需要重新拉取？

---

### 4. 生命周期与环境变化

**典型例子**
- 切换 tab / 返回页面
- 断网重连
- 页面重新聚焦

**隐含工程问题**
- 什么时候自动刷新？
- 如何避免无意义请求风暴？
- 数据“看起来没变但已过期”如何处理？

---

## 三、HTTP 并发管理的工程问题清单（核心）

当你说“HTTP 并发管理”时，实际上至少包含以下子问题：

1. 去重（Deduplication）
2. 取消（Cancellation / Abort）
3. 竞态控制（Race Condition）
4. 缓存（Caching）
5. 过期与刷新（Stale / Refetch）
6. 共享状态（Shared Server State）
7. 失败与重试策略（Retry / Backoff）
8. 资源回收（GC / Memory）
9. 状态可观测性（Loading / Error / Success）

> 这些问题中，只有“发起请求”本身属于 Promise 的职责。
> 其余全部是工程治理问题。

---

## 四、为什么不应该手写 Promise 链解决

手写 Promise 链通常会导致：
- 时间线散落在 useEffect / 事件 / 回调中
- 取消、竞态、缓存逻辑重复出现
- 请求生命周期与组件生命周期耦合
- 行为难以证明正确性

最终结果是：
> **代码能跑，但系统不可推理。**

---

## 五、工程方案的角色定位（以 React Query 为代表）

成熟工程方案的价值在于：
- 用统一协议描述请求（queryKey）
- 用统一规则治理并发（去重 / 取消 / 缓存）
- 用统一生命周期对齐 UI（mount / focus / reconnect）

它们解决的是：
> **如何让 HTTP 并发在复杂系统中仍然可控。**

而不是：
- Promise 怎么写
- then 的顺序是什么

---

## 六、一个工程判断原则

你可以用这句话判断是否需要“HTTP 并发管理方案”：

> **只要一个请求存在“重复触发 / 多处使用 / 生命周期不确定”，就不该由组件自己管理。**

---

## 七、总结

- Promise 是工具，不是答案
- HTTP 并发问题本质是工程治理问题
- 正确做法是：
  - 明确问题空间
  - 使用成熟方案
  - 避免手写时间线拼图

> **当你在讨论 HTTP 并发时，如果话题变成 Promise 细节，说明问题已经跑偏了。**



# HTTP 并发管理工程 Playbook（前端）

> 目标：把“多个 HTTP 请求同时发生”这件事，从**组件里的 Promise 细节**，上移到**可治理的工程层**。
>
> 你说“HTTP 并发管理”，通常不是在说 `fetch` 或 `Promise`，而是在说一组可预期会出事故的子问题：
> **去重 / 取消 / 竞态 / 缓存 / 过期刷新 / 共享状态 / 重试 / 资源回收 / 状态可观测性**。

---

## 0. 一句话定义

**HTTP 并发管理** = 在多请求、多触发点、多组件订阅的情况下，让“请求的时间线”和“UI 的时间线”保持可推理、可控制。

---

## 1. 典型业务触发场景（先从场景定义问题）

### 1.1 多个不同请求并发（fetchA / fetchB / fetchC）

- 页面初次进入：同时拉取列表、筛选项、权限、用户信息
- Dashboard：多个卡片各自请求
- 详情页：基础信息 + 关联列表 + 统计数据并发

**主要风险**：
- 请求顺序不确定导致 UI 状态切换抖动
- 某一个失败导致整体体验崩坏（错误传播策略）

### 1.2 同一个请求在短时间内被多次触发（搜索 / 联想 / 滚动加载）

- 搜索框输入：每个 keystroke 触发一次
- 联想：快速输入 + 网络慢 → 旧结果覆盖新结果
- 无限滚动：滚动触发频繁；重复触发同一页

**主要风险**：
- 重复请求（浪费）
- 竞态（旧覆盖新）
- 取消缺失（无意义请求还在飞）

### 1.3 多组件共享同一份服务端数据

- 列表页 + 统计栏 + 筛选条件面板共享同一 query
- 详情页多个 Tab 共用同一实体数据

**主要风险**：
- 组件各自维护一份 state → 不一致
- 刷新/更新后，其他区域不同步

---

## 2. 工程子问题清单（核心）

当你说“HTTP 并发管理”时，至少包含以下子问题：

1. **去重（Deduplication）**
2. **取消（Cancellation / Abort）**
3. **竞态控制（Race Condition）**
4. **缓存（Caching）**
5. **过期与刷新（Stale / Refetch）**
6. **共享状态（Shared Server State）**
7. **失败与重试策略（Retry / Backoff）**
8. **资源回收（GC / Memory）**
9. **状态可观测性（Loading / Error / Success）**

> 经验：
> - 这些问题**不应该**通过“组件里手写 Promise 链”解决。
> - 组件里手写 Promise，最大的问题不是语法，而是：**时间线散落**、**边界不清**、**复用困难**、**全靠工程师记忆兜底**。

---

## 3. React Query 如何逐项解决（问题 → 机制 → 工程价值）

> 说明：这里讲的是工程机制，不是 API 说明书。

### 3.1 去重（Deduplication）

**机制**：基于 `queryKey` 的请求级去重（同 key 共享同一次 in-flight 请求 / Promise）。

**工程价值**：
- 多组件/多次触发不会造成重复 HTTP
- 去重逻辑集中在调度层，不散落在各个 `useEffect`

---

### 3.2 取消（Cancellation / Abort）

**机制**：支持基于 `AbortController` 的取消（前提：你的 queryFn/底层 fetch 支持 signal）。

**工程价值**：
- 组件卸载 / 请求失效时可主动终止无意义请求
- 避免“页面都走了，网络还在飞”的资源浪费

> 工程边界：
> - 取消是否真正生效，取决于你的请求实现是否正确传递 `signal`。

---

### 3.3 竞态控制（Race Condition）

**机制**：同一 query 的多次 fetch 有内部的“当前有效请求”概念；旧请求返回时如果已失效，结果不会覆盖最新状态。

**工程价值**：
- 不需要手写 `latestRequestId`、时间戳、布尔标志位
- “搜索联想”这种场景最常见、也最容易救命

---

### 3.4 缓存（Caching）

**机制**：Query Cache（内存缓存）按 `queryKey` 索引存储结果。

**工程价值**：
- 页面来回切换不必反复请求
- 减少 UI 抖动（可先显示缓存，再决定是否刷新）

---

### 3.5 过期与刷新（Stale / Refetch）

**机制**：
- `staleTime`：数据多久后被视为“可能过期”
- `cacheTime`：无人订阅后保留多久再回收
- 自动刷新触发点：重新挂载、窗口聚焦、网络重连等（可配置）

**工程价值**：
- 明确区分：**可用（cached）** vs **最新（fresh）**
- 把“何时刷新”从组件判断中抽离出来

---

### 3.6 共享状态（Shared Server State）

**机制**：Server State 被统一建模为 Query；多个组件订阅同一 Query，天然共享同一份数据与状态。

**工程价值**：
- 不必把服务端数据塞进 Redux/Context 再自己同步
- invalidate / refetch 可以“一次触发，处处同步”

---

### 3.7 失败与重试策略（Retry / Backoff）

**机制**：可配置 retry 次数与间隔（常见是指数退避），可按错误类型区分是否重试。

**工程价值**：
- 失败治理集中：不再每个 `fetch` 旁边都写 try/catch + setTimeout
- 更贴近网络现实：失败是常态，不是异常

---

### 3.8 资源回收（GC / Memory）

**机制**：基于订阅计数与 `cacheTime` 的 GC；无人订阅后在一定时间后回收。

**工程价值**：
- 缓存不会无限增长
- 避免“长生命周期应用 + 多页面访问”造成的隐性内存问题

---

### 3.9 状态可观测性（Loading / Error / Success）

**机制**：标准化的请求状态机（loading / fetching / error / success 等）与 error/data 结构。

**工程价值**：
- UI 状态可推理、可组合
- 不再混用 `useState` 自造状态机导致分支爆炸

---

## 4. 什么时候不应该用 React Query（工程边界）

React Query 解决的是：**“服务端数据（Server State）的获取与并发治理”**。

不适合 / 不建议的情况：

- **纯 UI 状态**：比如弹窗开关、输入框本地值（应该用 state）
- **强事务型、强一致性写入流程**：需要你自己设计业务事务边界（React Query 只能帮助你“拉与同步”，不能替你定义事务）
- **不应该被缓存的数据**：一次性敏感数据、一次性 token（除非你非常明确 cacheTime=0 的策略）

---

## 5. 最小落地策略（团队可执行）

如果一个 20 人左右的业务团队想把“HTTP 并发事故”压下去：

1. **统一 queryKey 约定**：资源维度、参数维度、用户维度（谁负责定义与评审）
2. **统一取消策略**：queryFn 必须支持 signal（否则“取消”是假的）
3. **明确 staleTime 分层**：
   - 强实时（秒级）
   - 可接受陈旧（分钟级）
   - 近似静态（小时级）
4. **明确错误策略**：哪些错误重试、哪些不重试、错误如何呈现
5. **明确 invalidate 规范**：写入后 invalidate 哪些 key（避免“写了但 UI 不刷新”）

---

## 6. 一句话总结（你可以在讨论/面试时使用）

> React Query 的价值不在于“帮你写 Promise”，而在于：
> **它把 HTTP 并发中最容易出事故的九类工程问题，上移到一个可治理的系统里。**

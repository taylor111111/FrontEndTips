# Promise 在前端工程中的问题空间（Engineering Problem Space）

> 这不是一篇 Promise API 教程。
>  
> 这是一份 **工程级视角** 的问题定义文档，用来回答一个核心问题：
>
> **Promise 在前端工程中，究竟解决了哪些问题，又制造了哪些风险？**

---

## 一、一个核心前提：Promise 不是问题本身

Promise 本身并不复杂。

复杂的是：
- Promise **必然嵌入某条时间线**
- 且常常与 **其他时间线并行或交错**

前端工程中常见的时间线包括：

- 用户事件（click / input）
- React render / commit
- React effect
- 浏览器任务队列（macro / micro）
- 定时器（setTimeout / setInterval）
- 网络请求（fetch / xhr）

👉 **Promise 的工程难度，来自时间线管理，而不是语义理解。**

---

## 二、Promise 牵扯的核心工程问题清单

### 1. 时间线失控问题（最核心）

**问题表现：**
- Promise 何时被创建？
- 会被触发多少次？
- 是否可能并发执行？
- 是否可能重复执行？

**高风险场景：**
- Promise 写在 render 路径中
- Promise 写在 setTimeout / setInterval 中
- Promise 的触发频率不受控

**工程判断：**
> 如果你无法一句话说清楚「这个 Promise 会被触发几次」，  
> 那它已经是一个工程风险点。

---

### 2. 并发管理问题（HTTP 请求最常见）

**典型场景：**
- 多个不同请求并发（fetchA / fetchB / fetchC）
- 同一个请求在短时间内被多次触发（搜索、联想、滚动加载）

**工程问题包括：**
- 是否需要去重？
- 是否需要取消旧请求？
- 是否需要缓存？
- 是否需要共享状态？

👉 这类问题 **不应该通过手写 Promise 链解决**，  
而应该交给工程方案（如 React Query）。

---

### 3. 生命周期错位问题

**常见错误：**
- 组件已卸载，但 Promise 仍然 resolve
- resolve 后尝试 setState
- 产生内存泄漏或 warning

**本质问题：**
> Promise 的生命周期，和组件生命周期是两套系统。

**工程结论：**
- Promise 必须被绑定在明确的生命周期边界内
- 否则就需要额外的取消 / 忽略机制

---

### 4. 状态一致性问题（Stale / Race）

**问题表现：**
- 后返回的请求覆盖先返回的正确结果
- 使用 Promise.then 读取到过期 state
- 多个 Promise 同时修改同一份状态

**本质：**
- Promise 是 **无状态的**
- 状态一致性是 **工程层责任**

---

### 5. 错误处理扩散问题

**常见误区：**
- 每个 Promise 都自己 catch
- catch 吃掉错误
- 错误处理逻辑分散在各处

**工程后果：**
- 错误路径不可预测
- 调试成本极高

---

## 三、哪些工程场景下，Promise 是“必要且安全”的

### ✅ 推荐使用场景（边界清晰）

1. `useEffect(() => { ... }, [])`
   - 只触发一次
   - 生命周期明确

2. `onClick / onSubmit`
   - 用户驱动
   - 触发频率可控

3. 单一、短生命周期的异步任务
   - 明确开始
   - 明确结束

👉 特点：**时间线单一、不并发、不叠加**

---

## 四、哪些场景下一定不要“直接使用 Promise”

### ❌ 高风险 / 不建议

- 在 render 路径中创建 Promise
- 在 setTimeout / setInterval 中无约束使用 Promise
- 手写 Promise 链管理复杂并发请求
- 用 Promise 解决状态同步问题

这些都属于：
> **用语言机制，强行承担工程复杂度**

---

## 五、工程结论（非常重要）

- Promise 是 **底层机制**
- 工程问题需要 **工程方案**
- 能用库解决的问题，不要用 Promise 证明自己

> **理解 Promise 的价值，不在于“会写”，  
> 而在于知道：什么时候不该自己写。**

---

## 六、一句话工程判断准则

你可以用这句话快速判断：

> **如果一个 Promise 的正确性，依赖于“其他 Promise 是否完成 / 是否被取消 / 是否先后返回”，  
> 那它已经超出了手写 Promise 的安全边界。**

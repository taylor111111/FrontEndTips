

# ES6：工程价值，而不是语法清单

这篇文章不是 ES6 特性罗列，也不是“你必须记住的 30 个新语法”。

它回答的是一个工程级问题：

> **哪些 ES6 能力，真正降低了工程风险、提高了长期可维护性？**

如果一个特性：
- 只增加表达花样
- 却没有降低理解成本  
那它的工程价值就非常有限。

---

## 1. 判断 ES6 是否“值钱”的标准

在工程语境下，我通常用三条标准判断一个 ES6 特性是否值得长期持有：

1. **是否减少隐式行为**
2. **是否让状态或依赖边界更清晰**
3. **是否降低长期维护和 debug 成本**

能同时满足 ≥2 条的，才是“高价值 ES6”。

---

## 2. 最值钱的 ES6 能力（Top Tier）

### 2.1 块级作用域（let / const）

这是 ES6 最重要、也是最具工程意义的改变。

#### 为什么值钱

- 明确变量的生命周期
- 消灭 `var + 闭包 + 循环` 的整类历史 bug
- 提升代码的**局部可推理性**

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100)
}
```

这里的 `i` 是：
- 每一轮循环独立的绑定
- 而不是共享的可变状态

#### 工程原则

- 默认使用 `const`
- 需要重新赋值时才使用 `let`
- 避免任何形式的 `var`

---

### 2.2 引用语义：ES6 没改变它，但暴露了它

ES6 并没有改变 JavaScript 的值 / 引用模型，
但通过 `const`、展开运算符等语法，让**误用引用更常见**。

```js
const arr = [1, 2, 3]
const copy = arr
copy.sort()
```

#### 工程事实

- `copy` 和 `arr` 指向同一个数组
- mutation 会影响所有持有该引用的代码

#### 高价值能力

- 区分 **reassign** 与 **mutation**
- 理解 `const` 只约束绑定，不约束内容
- 在设计上避免“隐式共享状态”

---

### 2.3 展开运算符（...）不是深拷贝

```js
const next = { ...prev }
```

#### 常见误解

> “我已经复制了一份数据”

#### 实际语义

- 这是 **浅拷贝**
- 嵌套对象仍然共享引用

#### 工程判断力

- 什么时候可以安全使用（扁平结构）
- 什么时候必须引入深拷贝或结构重构
- 是否应该减少嵌套数据本身

---

### 2.4 解构：显式依赖声明

```js
function render({ title, content }) {}
```

解构的真正工程价值不在“少写字”，而在于：

> **明确声明：我依赖哪些字段**

#### 工程收益

- 降低函数对外部结构的耦合
- 提高接口的自解释性
- 让 refactor 更安全

---

### 2.5 默认参数的时间语义

```js
function fn(a = getValue()) {}
```

#### 关键事实

- 默认参数在 **函数调用时** 求值
- 拥有独立的作用域

#### 工程风险点

- 在默认参数中引入副作用
- 假设它是“定义时求值”

---

## 3. 中等价值，但需要克制使用的特性

### 3.1 箭头函数（arrow function）

箭头函数最大的工程价值不是语法简洁，而是：

> **this 由动态绑定，变为词法捕获**

#### 工程影响

- 降低 this 相关 bug
- 更适合回调、hooks、函数组合
- 提高函数语义一致性

#### 工程态度

- 在不确定调用环境是否稳定时，避免使用 `this`
- 使用箭头函数表达“无自身上下文的函数”

---

### 3.2 Class：不是新模型，只是语法包装

```js
class A extends B {}
```

#### 工程真相

- class 并没有引入新的对象模型
- 本质仍然是 prototype
- 继承关系依然隐式、难以追踪

#### 工程建议

- 避免深层继承
- 更倾向组合而非继承
- 不把 class 当作“高级抽象工具”

---

## 4. 低价值或高风险特性（识别即可）

### 4.1 Symbol / Iterator

- 对库作者有价值
- 对业务工程师收益极低

---

### 4.2 Generator / Async Generator

- 强大但心智负担极高
- 维护成本大于收益

---

### 4.3 Proxy / Reflect

- 非常灵活
- 非常难 debug
- 极易制造隐式行为

> 工程上：**能不用就不用**

---

## 5. 一个工程级总结

ES6 的真正价值不在于“新”，而在于：

- 是否减少隐式行为
- 是否约束可变性
- 是否让代码更容易被他人理解

> **真正优秀的工程师，不是会用所有特性，  
而是知道哪些特性不值得用。**

---

## 6. 面试安全回答模板

当被问及 ES6 相关问题时，一个成熟、低风险的回答思路是：

> 我更关注 ES6 是否帮助我降低工程风险。  
> 比如通过块级作用域、显式解构、限制可变性，  
> 而不是单纯追求语法技巧。

这不是保守，
而是**工程成熟度**。

# React.memo：组件边界上的性能工具，而不是默认模板

在 React 的性能类 API 中，`React.memo` 是一个**看起来简单、但极易被误用**的工具。

很多团队把它当作“组件的默认外壳”，或者把它当成“性能问题的止痛药”，
这几乎总是错误的。

本文从 **设计目的 → 什么时候应当使用 → 不建议使用的场景 → 明确禁止的使用边界** 四个层面，重新把 `React.memo` 放回它真实、有限、且可验证的工程位置。

---

## 一、React.memo 的设计目的

### 1. 一句话定义（工程语义版）

> **`React.memo` 用来在组件边界上，基于 props 的 identity，对一次“不必要的 render”进行短路。**

这句话里每一个词都很重要：

- **组件边界（component boundary）**
- **props identity（Object.is 的浅比较）**
- **跳过 render，而不是跳过更新**
- **不必要（unnecessary）**

`memo` 并不是“让组件更快”，
而是在声明一件更严肃的事：

> **“在 props 未变化的前提下，这个组件的 render 结果是等价的。”**

这是一个**纯度声明（purity assertion）**。

---

### 2. memo 在 React 模型中的真实位置

React 的默认渲染模型是：

> **父组件 render → 子组件 render**

这是一个非常重要、也非常简单的默认假设。

`React.memo` 做的事情，是在这个传播路径上插入一个判断点：

> **“等一下，如果 props 没变，这里可以不用重新算。”**

这意味着：

> **使用 memo，本身就是在与 React 的默认模型进行一次有成本的谈判。**

---

## 二、什么时候应当使用 memo（工程上成立的场景）

以下场景中使用 `React.memo`，
在工程上是**合理、清晰、且收益可解释的**。

---

### 1. 子组件是明确的 expensive subtree

所谓 *expensive*，并不是感觉，而是可以被验证的事实，例如：

- render 逻辑复杂
- JSX 结构庞大
- 包含大量子组件
- render 中存在可观的计算成本

并且，这些成本是可以通过 React Profiler 观察到的。

> **这是 memo 的本职工作。**

---

### 2. 父组件 render 频繁，但子组件 props 变化很少

这是 memo 最经典、也最“值”的使用场景。

典型情况包括：

- 父组件因为 state / context 高频更新
- 子组件只是展示型或计算型
- 子组件 props 的变化频率显著低于父组件 render 频率

在这种情况下，memo 可以显著减少无意义的 render。

---

### 3. 组件在语义上是“纯组件”

如果你能够非常确信：

> **“给定相同的 props，这个组件的 render 结果一定相同。”**

那么 memo 在**语义层面是成立的**。

注意：

- 这是对组件语义的判断
- 不是对实现细节的猜测

---

## 三、不建议使用 memo 的场景（危险信号）

下面这些情况并非立刻错误，
但通常意味着：

> **memo 带来的复杂度，很可能已经超过了它带来的收益。**

---

### 1. 子组件 render 成本本身非常低

这是 memo 最常见、也最容易被忽略的误用。

如果组件：

- JSX 很少
- 没有复杂计算
- render 成本 < props 比较成本

那么 memo 的存在，反而会让系统变慢。

---

### 2. props 的 identity 本身不稳定

例如：

```ts
<Child data={{ a, b }} />
```

即使包裹了 memo：

- 每次 render 都会生成新的 object
- 浅比较永远失败

在这种情况下，memo 只是一个装饰性的存在。

---

### 3. 出于“以防万一”的心理使用 memo

```ts
export default memo(function Component() { ... })
```

如果使用理由是：

> “先包一层 memo，以后可能有用。”

那么这是**没有工程依据的复杂度引入**。

---

## 四、什么时候一定别用 memo（工程红线）

下面这些场景，可以非常明确地认为：

> **不要使用 React.memo。**

---

### 1. 用 memo 掩盖不清晰的状态或数据流设计

如果你发现：

- 父组件 render 次数异常
- 状态职责混乱
- memo 被用来“止血”

那么问题根本不在子组件。

> **memo 不能修复坏的状态建模。**

---

### 2. 把 memo 当作默认的组件模板

在组件定义阶段就无条件包裹 memo，
意味着：

- 优化被当成默认
- 判断被提前跳过
- 复杂度被静默扩散

这是非常不健康的工程习惯。

---

### 3. 在依赖隐式数据源的组件上使用 memo

如果组件：

- 依赖 Context
- 依赖外部可变数据
- render 结果并非只由 props 决定

那么 memo 的“纯度假设”本身就是不成立的。

这不是性能问题，而是**逻辑错误**。

---

## 五、一个通用且可靠的判断法则

在考虑是否使用 `React.memo` 时，可以问自己一句：

> **“这个组件如果重新 render 一次，我是否真的付出了不可接受的成本？”**

- 如果 **没有** → ❌ 不要使用 memo
- 如果 **有，而且可证明** → ✅ memo 值得考虑
- 如果你说不清楚 → ⚠️ 默认不用

这个判断法则，比任何“最佳实践列表”都更可靠。

---

## 六、最终总结

> **React.memo 是一个性能边界工具，而不是结构性工具。**

它的工程定位应当是：

- 使用前有明确理由
- 使用后能测量收益
- 不改变组件语义
- 不掩盖更深层的设计问题

当 memo 被用来：

- 作为默认模式
- 装饰代码
- 逃避状态与数据流建模问题

它就会从一个有价值的优化手段，
退化为一个**认知负债的制造者**。

# Error Boundary：事故隔离装置，而不是稳定性工具

在 React 的错误处理机制中，**Error Boundary** 是一个经常被误解的概念。

很多团队把它当成“防止白屏的保险丝”，甚至当成“系统稳定性的组成部分”，
但这两种理解都会导致 Error Boundary 被严重滥用。

Error Boundary 并不是用来“修复错误”的，
而是用来**在错误已经发生时，阻止系统整体坍塌**。

本文从 **设计目的 → 推荐使用场景 → 最好别用的情况 → 明确禁止的使用边界** 四个层面，
重新界定 Error Boundary 在工程中的真实位置。

---

## 一、Error Boundary 的设计目的

### 1. 一句话定义（工程语义版）

> **Error Boundary 用来在组件树边界上，
> 捕获“渲染阶段的不可恢复错误”，并将其隔离在局部范围内。**

这句话中的每一个关键词都非常重要：

- **组件树边界**：错误被限制在子树内，而不是扩散到整个应用
- **渲染阶段**：发生在 render / lifecycle 中的错误
- **不可恢复错误**：程序员错误，而不是业务错误
- **隔离（containment）**：阻止级联失败

Error Boundary 的核心目标只有一个：

> **当错误已经发生时，避免整个 React 应用一起崩溃。**

---

### 2. Error Boundary 解决的根本问题

React 默认的错误模型是非常激进的：

> **一旦 render 阶段抛出异常，整棵 React 树会被卸载。**

在工程上，这意味着：

- 一个局部的渲染错误
- 可能直接导致整个页面白屏

Error Boundary 的存在，就是为了阻断这种“全局坍塌”。

---

### 3. Error Boundary 的真实定位

你可以把 Error Boundary 理解为：

> **React 世界里的“断路器（circuit breaker）”。**

它的职责是：

- 隔离错误
- 提供可控的降级 UI
- 为日志、监控、恢复留出空间

而**不是**：

- 掩盖 bug
- 延续错误状态
- 替代正确的设计

---

## 二、什么时候推荐使用（工程上成立）

下面这些场景，使用 Error Boundary 是**合理、专业且负责任的**。

---

### 1. 保护复杂、非关键的 UI 子树

典型例子包括：

- 数据可视化图表
- 富文本编辑器
- 动态渲染的插件模块
- 高复杂度的交互组件

这些模块的共同特点是：

- 实现复杂
- 出错概率相对较高
- 出错后不应拖垮整个页面

> **这是 Error Boundary 的本职工作。**

---

### 2. 包裹第三方或不完全可控的代码

当你使用：

- 第三方 UI 组件库
- 外部可视化 / 编辑器
- 动态加载的模块

Error Boundary 相当于一份**工程保险**：

> **你承认这些代码并非完全可控，因此需要隔离风险。**

---

### 3. 页面级 / 路由级的容错设计

例如：

- 每个 route 包裹一层 Error Boundary
- 页面级 fallback（刷新 / 返回首页）

这是用户体验层面**合理且常见的降级策略**。

---

## 三、什么时候最好别用（危险信号）

下面这些情况并非立刻错误，
但通常意味着：

> **系统正在长期运行在“错误已被容忍”的状态中。**

---

### 1. Error Boundary 被频繁触发

如果你发现：

- fallback UI 经常出现
- 团队对错误“习以为常”
- Error Boundary 成了常态路径

那说明：

> **系统已经在持续吞掉程序员错误。**

这是一个非常危险的信号。

---

### 2. 用 Error Boundary 掩盖确定性的 bug

例如：

- 明确可复现的渲染错误
- 每次进入必然抛错
- 因为“先兜底”而长期不修

这本质上是：

> **对工程责任的放弃。**

---

### 3. 在组件内部随意包 Error Boundary

```tsx
function Component() {
  return (
    <ErrorBoundary>
      <SubComponent />
    </ErrorBoundary>
  )
}
```

如果你正在写这个组件，
那么你本应**修复错误源头**，而不是捕获它。

---

## 四、什么时候一定别用（工程红线）

下面这些场景，可以非常明确地认为是**工程错误**。

---

### 1. 用 Error Boundary 捕获“你本该处理的错误类型”

Error Boundary **不能、也不应当**用于捕获：

- 事件处理错误（onClick 等）
- 异步错误（Promise / fetch）
- 业务校验失败

如果你试图用 Error Boundary 解决这些问题：

> **说明你混淆了错误模型。**

---

### 2. 把 Error Boundary 当成控制流工具

```ts
throw new Error('reset component')
```

这是严重的反模式。

原因在于：

- Error 是异常
- 不是状态
- 更不是流程信号

---

### 3. 在核心业务路径上依赖 Error Boundary 继续运行

如果某条路径：

- 经常抛错
- 但你“允许它失败”
- 靠 Error Boundary 继续提供服务

那这条路径本身就不应存在。

---

## 五、一个非常重要但常被忽略的事实

> **Error Boundary 捕获的错误，本质上是“程序员错误（programmer error）”，
> 而不是“用户错误”或“环境错误”。**

这意味着：

- 错误本不应发生
- Error Boundary 只是事故隔离

一旦你开始**依赖它的存在**，
它就已经失去了正当性。

---

## 六、一个可靠的判断法则

在考虑是否使用 Error Boundary 时，可以问自己一句：

> **“这个错误如果发生，我是否还能让用户安全、明确地继续使用系统？”**

- 如果 **可以** → Error Boundary 合理
- 如果 **不可以** → 不应继续运行
- 如果你说不清楚 → 默认不要用

---

## 七、最终总结

> **Error Boundary 是事故隔离装置，而不是系统稳定性工具。**

它的工程定位应当是：

- 少量存在
- 位于外围
- 可观测、可追责

一旦 Error Boundary：

- 频繁触发
- 成为常态
- 被当成“兜底设计”

它就会从一个必要的安全机制，
退化为**系统腐蚀的掩体**。

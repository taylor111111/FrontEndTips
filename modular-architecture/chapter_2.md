# 5. 懒加载带来的工程问题 & 处理方式

你问的重点是这个：

> **“懒加载之后，工程里会衍生出哪些问题，要怎么处理？”**

我帮你拆几个最关键的。

---

## 5.1 用户体验：加载状态 & 失败重试

问题：

- chunk 下载需要时间
- 网络失败怎么办？
- 用户看到的不是“白屏是命”，而是：
  - loading skeleton
  - 错误提示 / 重试按钮

常见方案（React 语境）：

- `React.Suspense + fallback`
- 自己封装一个 `withAsyncComponent(loadFn, { Loading, Error })` HOC
- 对“关键路径的懒加载”配合 prefetch / 提前加载

你可以理解为：**懒加载必须要 UI 级别的“状态机”来兜底**：

```text
idle → loading → success / error → retry
```

---

## 5.2 监控 & 出问题的调试

常见痛点：

- 某个 chunk 特别大 → 首屏慢
- 某个业务只在日本用户访问 → 但 chunk 大小持续膨胀
- 某个懒加载 chunk 在生产上偶发加载失败 → 只能靠日志排查

工程上一般会做：

### 1. Bundle 分析

- Webpack Bundle Analyzer / source-map-explorer
- 看哪些模块没进主包、哪些 chunk（例如：公共组件库没被打进某个业务路由）

### 2. 错误上报

- 对 `import()` 的失败加一层统一捕获 & 上报

### 3. 预加载策略

- `link rel="preload/prefetch"`
- 或在进入关键路径之前静默加载 chunk

---

## 5.3 SSR / Hydration 与懒加载的配合

如果你后面做 SSR（Next.js 或自建）：

- 服务端可能用同步 module 图渲染首屏
- 客户端 hydration 时，某些组件是懒加载的 → 需要保证 initial HTML 与后续 hydration 对上

常见处理：

- 对“首屏必须组件”不要做懒加载
- 或用框架内置方案：
  - Next.js：`next/dynamic` + `ssr: false`
  - Vue：`defineAsyncComponent` + SSR 配合策略

本质是：

> **服务端和客户端必须对“模块图的哪一部分已经加载”达成共识。**

---

## 5.4 代码结构随着懒加载变得“碎片化”

问题：

- 路由拆、组件拆、子模块拆 → 代码很容易变成碎片
- “某个功能逻辑其实散落在多个按需加载的模块中”
- 不小心就会搞出：抽象失衡 或 交叉依赖

工程上的经验做法：

### 1. 懒加载边界 ≠ 业务边界 / UI 边界

- 例如：以页面为主，局部重组件为辅

### 2. 模块结构仍然按领域划分

```
features/order/
  ├── components/
  ├── services/
  └── model/
```

- 懒加载只是“入口路径不同”，不是文件随便丢

### 3. 保持一个“全局模块图”的脑内模型

- 就像你现在对 Fiber / React 整体结构的认知
- 懒加载 ≠ 给子树加了“延迟展开”的标记，不改变原本图结构

---

# 6. 把这一切抽象成一句你脑子会很舒服的描述

> **模块化开发 = 把代码组织成一个清晰的依赖图。**  
> **AMD / CMD 是早期的“运行时模块图”。**  
> **现在是：ESM + bundler 在构建期生成“静态模块图”。**

> **懒加载 = 在这张图上做“子图的延迟展开 + 调度问题”。**

工程问题，本质上就在这几件事之间打转：

- “图怎么划分（模块边界）”
- “子图什么时候展开（懒加载策略）”
- “展开失败 / 变慢如何处理（UX + 错误兜底 + 监控）”
- “如何保持结构仍然干净（避免环、避免碎片化）”

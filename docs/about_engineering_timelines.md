# Engineering Timelines：工程中的时间线模型

> **工程复杂度的本质，不是状态多，而是时间线混乱。**  
> 当系统里同时存在多条时间推进机制，而它们彼此不自知、无边界协作时，事故几乎是必然的。

本文尝试给出一个**工程可用**的统一抽象：  
把 Promise / setTimeout / React effect / 用户事件  
统一放进一张「时间线地图」中理解。

这不是 API 总结，而是一套**设计与验尸用的模型**。

---

## 1. 什么是“一条时间线”（工程定义）

在工程语境中，一条时间线 = 三个要素：

- **触发权**：是谁让它开始
- **推进规则**：它如何向前运行
- **生命周期**：它何时结束、是否可取消

只要三者不同，就**必须视为不同时间线**。

---

## 2. 四类常见时间线的工程画像

### 2.1 React 时间线（render / effect）

**角色**：当前世界  
**控制权**：React  
**推进规则**：state → render → commit → effect  
**生命周期**：mount → update → unmount  

特点：

- 不等待 Promise
- 不感知真实时间
- 可以随时中断你（unmount）
- 是所有副作用的“裁判者”

> React 不是异步系统，它只是**不等任何未来**。

---

### 2.2 用户事件时间线（click / input）

**角色**：外部刺激  
**控制权**：用户  
**推进规则**：用户触发 → 同步执行  
**生命周期**：瞬时、一次性  

特点：

- 不可预测
- 不可重放
- 不维护状态
- 只负责“点火”

> 用户事件不执行长期逻辑，它只负责触发。

---

### 2.3 Promise 时间线（async / await）

**角色**：结果生产者  
**控制权**：一旦启动即失控  
**推进规则**：pending → fulfilled / rejected  
**生命周期**：启动 → 完成（不可取消）  

特点：

- 没有世界感知
- 不知道组件是否还存在
- 不知道结果是否还有效
- 无法自行触发，只能被寄生启动

> Promise 的问题不在复杂，而在**它永远活在别人的时间线上**。

---

### 2.4 定时器时间线（setTimeout / setInterval）

**角色**：未来调度  
**控制权**：浏览器  
**推进规则**：真实时间到 → 回调执行  
**生命周期**：注册 → 触发 / 清理  

特点：

- 基于真实时间
- 与 React 生命周期无关
- 极易“过期”

> 定时器是一个**不看世界的闹钟**。

---

## 3. 统一的「时间线地图」

```txt
┌────────────────────────────────────────────┐
│                React 时间线                │
│                                            │
│  render ── commit ── effect ── cleanup     │
│     │                    ▲                │
│     │                    │                │
│     ▼                    │                │
│ 用户事件时间线            │                │
│   ● click                 │                │
│     │                     │                │
│     ▼                     │                │
│  触发 Promise / Timer     │                │
│     │                     │                │
│     ├──────────────┐      │                │
│     │              │      │                │
│ Promise 时间线      │ Timer 时间线         │
│ start ───▶ resolve  │ set ───▶ fire        │
│     │              │      │                │
│     └───────┬──────┘      │                │
│             ▼             ▼                │
│          setState / 副作用（危险点）       │
│                                            │
└────────────────────────────────────────────┘
```

**唯一的高危区域：**  
> 异步结果「回到」React 世界的那一刻。

---

## 4. 为什么时间线“重合”会制造事故？

因为不同时间线：

- 有不同的推进规则
- 有不同的生命周期
- 对“当前是否有效”的判断完全不同

当你默认它们**天然对齐**时，事故就出现了：

- 已 unmount 的组件被 setState
- 旧请求覆盖新请求
- 定时器在过期语境中执行
- “偶现 bug” 无法复现

---

## 5. 工程级时间线设计原则

### 原则 1：React 是唯一的世界时间线

其他时间线只能被**注册**，不能主导状态。

---

### 原则 2：Promise / Timer 永远不能直接决策

它们只能产出结果，  
**是否使用结果，由 React 决定**。

---

### 原则 3：时间线交汇点必须有合法性检查

```ts
useEffect(() => {
  let alive = true

  fetchData().then(data => {
    if (!alive) return
    setState(data)
  })

  return () => {
    alive = false
  }
}, [])
```

这不是技巧，这是**时间线过滤器**。

---

### 原则 4：一段代码，只推进一条时间线

- render：只计算
- effect：只注册 / 清理
- event handler：只触发
- async：只完成

---

## 6. 面试与设计中的一句话版本

> Promise 本身不复杂，  
> 难的是它和 React、事件、定时器  
> 属于不同时间线。  
>  
> 我的习惯是先画清时间线，  
> 再决定谁能触碰状态。

---

## 7. 结语

时间线是工程中**最高难度的抽象之一**。  
它不可见，但一旦失控，调试成本极高。

> **好的工程不是“没有异步”，  
> 而是每一条时间线都被清楚地看见、隔离、约束。**

这张时间线地图，  
不是用来教人写代码，  
而是用来在事故发生后，  
**重新理解世界为什么那样运行。**



# 关于 JavaScript 中的「修改（Mutation）与引用（Reference）」  
## ——真正值钱、会决定工程质量的 JS 基础

> 这不是一篇“语法基础总结”，  
> 而是一篇**工程事故复盘型的基础说明文档**。

在真实工程中，绝大多数 JavaScript 问题并不是因为：
- 不会 API
- 不懂语法
- 写错 if / for

而是因为：

> **对“值 / 引用 / 修改”的认知模型不清晰，  
导致状态被无意共享、无意修改、无意污染。**

这类问题：
- 不会立刻报错
- 极难 debug
- 但一旦出现，影响范围极大

因此，它们才是**真正值钱的 JS 基础**。

---

## 1. 一句话结论（工程立场）

> **JavaScript 的核心风险，不在语法，  
而在“多个名字是否指向同一份状态，以及修改是否被扩散”。**

理解 mutation 与 reference，  
本质上是在回答一个问题：

> **“我改的，到底是谁？”**

---

## 2. 值拷贝 vs 引用拷贝（Top 级工程考点）

### 2.1 基本事实

- 原始类型（number / string / boolean / null / undefined / symbol）  
  👉 赋值 = 拷贝值
- 对象 / 数组 / 函数  
  👉 赋值 = 拷贝引用

```js
const a = [3, 1, 2]
const b = a

b.sort()

console.log(a) // [1, 2, 3] ❌ a 被意外修改
```

### 2.2 典型误解（非常常见）

> “我操作的是 b，不是 a”

真实情况是：

> **a 和 b 指向同一块内存**

---

## 3. 原地修改（Mutation）是工程风险的放大器

### 3.1 哪些 API 会原地修改（必须刻在脑子里）

#### ❌ 原地修改（高风险）

- `Array.prototype.sort`
- `Array.prototype.reverse`
- `Array.prototype.splice`
- `push / pop / shift / unshift`
- 对象属性直接赋值

#### ✅ 返回新值（相对安全）

- `map`
- `filter`
- `slice`
- `concat`
- `toSorted / toReversed`（新）

### 3.2 工程原则（一句话）

> **只要对象是“共享状态”，  
就必须避免原地修改。**

---

## 4. 浅拷贝 ≠ 深拷贝（第二大事故源）

```js
const state = {
  user: {
    name: 'Alice'
  }
}

const next = { ...state }
next.user.name = 'Bob'
```

很多人以为：
> 只改了 next

实际上：
> **state.user 也被改了**

### 工程结论

- 展开运算符只拷贝一层
- 嵌套对象依然共享引用

---

## 5. 闭包捕获的不是“值”，而是“变量引用”

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100)
}
// 3 3 3
```

### 正确理解

> **闭包捕获的是同一个 `i` 变量，而不是当时的数值**

这是以下问题的根源：

- 定时器 bug
- React stale closure
- 异步状态错乱

---

## 6. “看起来像纯函数”，但其实在改外部状态

```js
function updateUser(user) {
  user.age++
}
```

调用方往往误以为：
> updateUser 返回了新状态

实际上：
> **它修改了传入对象本身**

### 工程原则

> **函数要么显式修改（并命名为 modify / mutate），  
要么完全不修改。**

---

## 7. 相等判断：对象相等 ≠ 结构相等

```js
{} === {} // false
```

### 工程影响场景

- React props 比较
- useEffect deps
- memo / 缓存
- 状态 diff

### 工程结论

> **对象默认只支持“引用相等”**

---

## 8. JSON 拷贝不是工程级深拷贝

```js
JSON.parse(JSON.stringify(obj))
```

### 会悄悄损坏的内容

- Date
- Map / Set
- undefined
- function
- 循环引用（直接报错）

### 工程立场

> **这是调试工具，不是工程工具。**

---

## 9. 不可变性（Immutability）存在的真实原因

不是为了“函数式优雅”，而是为了：

- 状态边界清晰
- 修改可追踪
- debug 路径短
- 历史状态可回溯

这就是：
- Redux
- React state
- 时间旅行调试

成立的基础。

---

## 10. 结构共享（Structural Sharing）是高级技巧

```js
const next = {
  ...prev,
  user: {
    ...prev.user,
    age: 18
  }
}
```

核心思想：

- **只拷贝被修改的路径**
- 其余结构共享引用

这是在：
- 性能
- 安全性
- 可预测性

之间取得平衡。

---

## 11. 面试中的工程级总结话术（非常实用）

你可以这样说：

> “我会特别关注对象是否被原地修改，以及是否存在无意的共享引用。  
> 很多线上 bug，本质上都是引用被错误共享导致的状态污染。”

这句话：
- 不八股
- 不炫技
- 但**非常工程**

---

## 12. 总结：为什么这些才是“真正的 JS 基础”

因为它们：

- 不依赖框架
- 不随版本过期
- 不靠记忆
- 直接决定系统稳定性

> **真正的 JS 基础，是：  
在一个充满共享状态和异步的世界里，  
让变化保持可控。**

---

## 附：一句工程宣言

> **如果你不知道某次修改会影响谁，  
那这次修改就是危险的。**

理解 mutation 与 reference，  
是迈向高级工程师的必经之路。



# 关于 JavaScript 中的 `this` ——一个工程视角的说明

> 这不是一篇“语法大全”，而是一篇**工程风险说明书**。

在 JavaScript 中，`this` 是一个非常有名、也非常容易被误用的机制。  
它并不“坏”，但它**隐式、运行时绑定、强依赖调用方式**的特性，使它在真实工程中成为一个**高风险点**。

本文的目标不是教你“怎么用 `this`”，  
而是回答三个更重要的问题：

- `this` **为什么容易出问题**
- **什么时候不该用**
- 在工程中，**更安全的替代方案是什么**

---

## 1. 一句话结论（工程立场）

> **`this` 是运行时绑定的隐式上下文。  
> 在调用链不稳定、阅读者不清楚调用方式的情况下，它会显著增加理解与 debug 成本。**

因此，在业务工程中：

- ✅ 我**理解 `this`**
- ⚠️ 我**把它当作风险点**
- ❌ 我**不会把它作为默认工具**

---

## 2. `this` 的本质：运行时绑定，而不是定义时确定

很多问题的根源在于这一点：

> **`this` 的值不是在函数定义时决定的，而是在函数“被如何调用”时决定的。**

这意味着：

- 同一个函数
- 在不同调用方式下
- `this` 可能完全不同

```js
function f() {
  console.log(this)
}

f()                 // window / undefined (strict)
obj.f = f
obj.f()             // obj
```

### 工程后果

- 阅读函数本身，**无法确定 `this` 是什么**
- 必须回溯调用路径
- 调试成本随调用层级指数上升

---

## 3. 为什么 `this` 在工程中是“高风险点”

### 3.1 隐式依赖，破坏可读性

```js
this.doSomething()
```

问题不是语法，而是：

- `this` 是谁？
- 从哪里来的？
- 是否稳定？
- 会不会在 refactor 中被破坏？

这些问题，**代码本身回答不了**。

---

### 3.2 调用方式轻微变化，就可能产生 bug

```js
const fn = obj.method
fn() // this 丢失
```

- 没有语法错误
- 没有类型错误
- 但行为已经改变

👉 这是工程里最危险的一类 bug：**“静默错误”**

---

### 3.3 `this` 强依赖约定，而不是结构

- 约定：  
  “大家都知道这里要用 bind”
- 结构：  
  “函数签名明确表达依赖”

工程更偏好后者。

---

## 4. 面试中如何看待 `this`

### 推荐的工程级回答方式

> “`this` 是运行时绑定的，在调用链复杂或上下文不稳定的情况下，会引入隐式依赖。  
> 在工程实践中，我会把它当作一个风险点，只有在上下文非常明确、稳定的场景才会使用。”

这是一个**成熟工程师**的立场，而不是逃避。

---

## 5. 工程中更安全的替代方案

### 5.1 显式参数（首选）

```js
function render(user) {
  console.log(user.name)
}
```

- 依赖清晰
- 易测试
- 易重构

---

### 5.2 闭包（次优，但可控）

```js
function createLogger(user) {
  return () => {
    console.log(user.name)
  }
}
```

- 依赖绑定在创建时
- 不依赖调用方式

---

### 5.3 纯函数 + 数据流

```js
const nextState = reducer(prevState, action)
```

这是 React / Redux / 函数式编程偏好的根本原因之一。

---

## 6. 那什么时候可以用 `this`？

`this` 并非“禁止使用”，而是**需要满足条件**：

- 调用方式**高度稳定**
- 上下文**一眼可知**
- 风险被**局部封装**

例如：

- 类的私有方法（且不外传）
- 框架/库的内部实现
- 明确绑定（`.bind`）且不可变

---

## 7. 为什么工程上会“刻意避免 `this`”

因为工程追求的是：

- 可读性
- 可维护性
- 可 debug 性
- 可迁移性

而不是：

- 语言特性覆盖率
- 语法技巧展示

> **“我能不用，就不用”  
> 本身就是一种高级工程判断。**

---

## 8. 总结

- `this` 是 JavaScript 的一部分，但不是工程的必需品
- 它的复杂性来自**隐式 + 运行时**
- 高级工程师的能力，体现在**克制使用复杂工具**
- 在大多数业务代码中：
  - **显式依赖 > 隐式上下文**

> **理解它，是为了避免它。**

---

## 附：一句工程宣言

> **如果某个特性会显著增加阅读和 debug 成本，  
> 那即使我“会用”，我也会选择不用。**

这不是保守，这是工程成熟。

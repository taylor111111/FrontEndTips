

# ES6 基础设施级特性（不用于业务代码）

> 本文专门解释 **Proxy / Symbol / Generator / WeakMap** 这一类 ES6 特性。
>
> 结论先行：
>
> **它们不是“不会用”，而是“不该在业务中用”。**
>
> 作为工程师，更合理的姿态是：
> - ✅ 知道它们是什么
> - ✅ 知道它们解决什么“语言或框架层问题”
> - ✅ 清楚地知道：**为什么业务代码中要避免使用**

---

## 一、统一判断原则（非常重要）

以下特性都满足同一组特征：

- 能力很强
- 抽象层级很低（接近语言 / 运行时）
- 行为不可见或不直观
- 一旦进入业务代码，**debug 与维护成本陡增**

> 👉 因此，它们**适合框架 / 基础设施层**，不适合业务表达。

---

## 二、Proxy —— 行为拦截器（语言级中间件）

### 它解决什么问题

> **我想在不改变使用方式的前提下，拦截对象的一切行为。**

Proxy 可以拦截：
- 属性读取 / 写入
- `in` / `delete`
- 函数调用 / `new`

典型使用场景（全部是框架层）：
- Vue 3 的响应式系统
- 依赖收集 / 访问追踪
- 调试工具 / DevTools

---

### 为什么不用于业务代码

- 行为不在调用点（不可推理）
- 副作用隐式发生
- 调用栈难以追踪

```js
obj.a // 表面是读取，实际可能触发大量逻辑
```

**工程结论**：
> Proxy 是“框架能力”，不是“业务表达工具”。

---

## 三、Symbol —— 不可冲突的隐形 key

### 它解决什么问题

> **我想给对象挂内部字段，但绝不能和用户字段冲突。**

典型使用场景：
- polyfill 扩展原生对象
- 框架内部私有字段
- 隐藏实现细节

---

### 为什么不用于业务代码

- 字段不可枚举
- 对阅读者不可见
- 调试时难以发现

**工程结论**：
> 业务代码需要“显式”，而不是“隐形”。

---

## 四、Generator —— 可暂停执行的控制流

### 它解决什么问题

> **我想手动控制一段流程的执行与暂停。**

历史与真实使用场景：
- async/await 的思想来源
- Redux-Saga 的副作用编排
- 自定义迭代器

---

### 为什么不用于业务代码

- 心智负担极高（状态机）
- 时间线隐式
- 可读性差

**工程结论**：
> 在业务层，async/await 已完全覆盖其价值。

---

## 五、WeakMap —— 不影响 GC 的附加数据结构

### 它解决什么问题

> **我想给对象关联数据，但不想阻止它被垃圾回收。**

典型场景（框架层）：
- DOM 节点 → 内部状态
- 对象 → 私有元数据
- 缓存但不控制生命周期

---

### 为什么不用于业务代码

- 生命周期不可预测
- 数据“什么时候消失”不可见
- 调试困难

**工程结论**：
> 业务代码应显式管理状态与生命周期。

---

## 六、统一工程结论（可直接用于面试）

> Proxy / Symbol / Generator / WeakMap  
> 都属于 **基础设施级能力**。
>
> 我会理解它们解决的问题，  
> 但在业务代码中会刻意避免使用，  
> 以保证代码的可读性、可调试性和可维护性。

---

## 七、你“知道但不用”，不是能力不足

恰恰相反：

> **能清楚地说出“为什么不用”，  
> 本身就是高级工程判断能力。**

业务代码追求的是：
- 清晰
- 可预测
- 可维护

而不是：
- 能力最大化
- 抽象炫技
- 语言边界测试

---

## 结语

> **不是所有语言能力，都应该进入业务代码。**

知道边界，  
比掌握更多特性，  
更重要。
